(library (mattie parsers language)
         (export program dot
                 (rename (defn definition)
                         (cat- catenation)
                         (and- conjunction)
                         (alt- disjunction)
                         (neg- complement)
                         (opt- option)
                         (rep- repetition)
                         (term- terminal)
                         (word atom)))
         (import (rnrs) (mattie parsers stateful))

  (define (tag-terminal t l)
    (lmap (lambda (s st) (cons (cons t s) st)) l))
  (define (tag-nullary t l)
    (lmap (lambda (s st) (cons (list t) st)) l))
  (define (tag-unary t l)
    (lmap (lambda (s st) (cons (cons t (car st)) (cdr st))) l))
  (define (tag-binary t l)
    (lmap (lambda (s st) (cons (cons t (cons (cadr st) (car st)))
                               (cddr st))) l))

  (define word
    (let* ((word-start (disj english-letter (one-of "_")))
           (word-cont (alt word-start decimal-digit (term "-"))))
      (tag-terminal 'atom (conc word-start (rep word-cont)))))

  (define term-
    (let ((term-part (disj (conj (comp (term "\"")) lang-1) (term "\\\""))))
      (tag-terminal 'term (cat (term "\"") (rep term-part) (term "\"")))))

  (define (paren s st) ((cat (term "(") ws* expr ws* (term ")")) s st))
  (define dot (tag-nullary 'dot (term ".")))
  (define uni-base (alt paren term- word dot))
  (define rep- (tag-unary 'rep (cat uni-base ws* (term "*"))))
  (define opt- (tag-unary 'opt (cat uni-base ws* (term "?"))))
  (define neg- (tag-unary 'neg (cat uni-base ws* (term "~"))))
  (define uni (alt rep- opt- neg- uni-base))
  (define (expr s st)
    ((conc ws* (alt alt- and- cat- (conj (comp defn) uni))) s st))
  (define alt- (tag-binary 'alt (cat uni ws* (term "|") ws* expr)))
  (define cat- (tag-binary 'cat (cat uni ws* expr)))
  (define and- (tag-binary 'and (cat uni ws* (term "&") ws* expr)))
  (define defn (tag-binary 'def (cat ws* word ws* (term "<-") ws* expr)))
  (define program (cat defn (rep defn) ws*))

  (define (px-lang s)
    (let ((r (program s '())))
      (and r (string=? (car r) "")
           (let ((defs (cdr r)))
             (validate-defs defs)
             (make-lang defs)))))

  (define arities
      `((cat . 2)
        (alt . 2)
        (and . 2)
        (rep . 1)
        (opt . 1)
        (neg . 1)
        (atom . 0)
        (term . 0)
        (dot . 0)))

  (define (get-syms d)
    (if (eq? (car d) 'atom) (list (cdr d))
      (case (cdr (assq (car d) arities))
        ((0) '())
        ((1) (get-syms (cdr d)))
        ((2) (append (get-syms (cadr d)) (get-syms (cddr d)))))))

  (define (validate-defs ds)
    (let ((rules (map cdadr ds)))
      (assert (member "main" rules))
      (let* ((ss (map (lambda (d) (get-syms (cddr d))) ds))
             (rs (fold-left append '() ss))
             (undefined-rules (filter (lambda (s) (not (member s rules))) rs)))
        (assert (null? undefined-rules)))))

  (define (unescape-term t)
    (let ((inner (substring t 1 (- (string-length t) 1))))
      (list->string
        (let loop ((cs (string->list inner)))
          (cond ((null? cs) cs)
                ((char=? (car cs) #\\)
                 (assert (not (null? (cdr cs)))) ;; grammar should ensure this
                 (loop (cons (cadr cs) (cddr cs))))
                (else (cons (car cs) (loop (cdr cs)))))))))

  (define (make-lang defs)

    (define handlers
      `((cat . ,conc)
        (alt . ,disj)
        (and . ,conj)
        (term . ,(lambda (t) (term (unescape-term t))))
        (opt . ,opt)
        (neg . ,comp)
        (dot . ,(lambda _ lang-1))
        (rep . ,(lambda (l) (if (eq? l lang-1) lang-t (rep l))))
        (atom . ,(lambda (a)
                   (define sym (string->symbol a))
                   (define (f s st)
                     (set! f (cdr (assq sym tbl)))
                     (f s st))
                   (lambda (s st) (f s st ))))))

    (define (linguify b)
        (apply (cdr (assq (car b) handlers))
               (case (cdr (assq (car b) arities))
                 ((0) (list (cdr b)))
                 ((1) (list (linguify (cdr b))))
                 ((2) (list (linguify (cadr b)) (linguify (cddr b)))))))

    (define (r t d)
      (let-values (((name body) (values (cdadr d) (cddr d))))
        (cons (cons (string->symbol name) (linguify body)) t)))

    (define tbl (fold-left r '() defs))

    (cdr (assq 'main tbl))))
