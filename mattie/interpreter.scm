(library (mattie interpreter)
         (export make-interpreter)
         (import (rnrs)
                 (mattie util)
                 (mattie parser)
                 (mattie parser monad)
                 (mattie parser combinators))

  (define (make-interpreter src entry-point)
    (let-when ((r (parse-language src))
               (_ (validate-defs r entry-point)))
      (make-lang r entry-point)))

  (define (get-syms d)
    (cond ((not (pair? d)) '())
          ((eq? (car d) 'atom) (list (cdr d)))
          (#t (case (car d)
                ((atom lterm rterm dot eof) '())
                ((rep opt neg call out) (get-syms (cdr d)))
                ((lcat rcat alt and map)
                 (append (get-syms (cadr d)) (get-syms (cddr d))))))))

  (define (validate-defs ds entry-point)
    (let ((rules (map cdadr ds)))
      (and (memq entry-point rules)
           (let* ((ss (map (compose get-syms cddr) ds))
                  (rs (fold-left append '() ss)))
             (null? (remp (λ (s) (memq s rules)) rs))))))

  (define (subp f)
    (λ (s) (letm ((s0 get-pos)
                  (_ (set-pos s))
                  (f f)
                  (_ eof)
                  (_ (set-pos s0)))
             (return f))))

  (define static-handlers ;; everything except atoms, which are handled
    `((lcat . ,concs)     ;; according to the production rule they name
      (alt . ,disj)
      (and . ,conj)
      (map . ,bind)
      (lterm . ,term)
      (rterm . ,(compose const return))
      (opt . ,opt)
      (neg . ,comp)
      (dot . ,lang-1)
      (eof . ,eof)
      (rep . ,reps)
      (out . ,(λ (f) (bind f (λ (s) (display s) (return s)))))
      (rcat . ,(λ (a b) (λ (s) (letm ((a (a s))
                                      (b (b s)))
                                 (return (string-append a b))))))))

  (define (linguify b hs)
    (let* ((k (if (pair? b) (car b) b))
           (h (cdr (assq k hs))))
      (case k ((dot eof) h)
              ((atom lterm rterm call) (h (cdr b)))
              ((rep opt neg out) (h (linguify (cdr b) hs)))
              ((lcat rcat alt and map)
               (h (linguify (cadr b) hs) (linguify (cddr b) hs))))))

  (define (make-lang defs entry-point)
    (define (dispatch a) (define-lazy f (cdr (assq a rules))) f)
    (define handlers
      (append static-handlers (list (cons 'atom dispatch)
                                    (cons 'call (compose subp dispatch)))))
    (define (defn t d) (cons (cons (cdadr d) (linguify (cddr d) handlers)) t))
    (define rules (fold-left defn '() defs))
    (cdr (assq entry-point rules))))
