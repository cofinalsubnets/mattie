(library (mattie interpreter)
         (export interpret-mattie)
         (import (rnrs)
                 (mattie util)
                 (mattie parser)
                 (mattie parser monad)
                 (mattie parser combinators))

  (define (interpret-mattie src entry-point)
    (let-when ((r (parse-mattie src))
               (_ (validate-defs r entry-point)))
      (make-procedure r entry-point)))

  (define (get-syms d)
    (cond ((not (pair? d)) '())
          ((eq? (car d) 'atom) (list (cdr d)))
          (#t (case (car d)
                ((atom lterm rterm dot eof) '())
                ((rep opt neg call rw out) (get-syms (cdr d)))
                ((lcat rcat alt and map)
                 (append (get-syms (cadr d)) (get-syms (cddr d))))))))

  (define (validate-defs ds entry-point)
    (let ((rules (map cdadr ds)))
      (and (memq entry-point rules)
           (let* ((ss (map (compose get-syms cddr) ds))
                  (rs (fold-left append '() ss)))
             (null? (remp (λ (s) (memq s rules)) rs))))))

  (define static-handlers ;; everything except atoms, which are handled
    `((lcat . ,concs)     ;; according to the production rule they name
      (alt . ,disj)
      (and . ,conj)
      (map . ,bind)
      (lterm . ,term)
      (rterm . ,(compose const return))
      (opt . ,opt)
      (neg . ,comp)
      (dot . ,lang-1)
      (eof . ,eof)
      (rep . ,reps)
      (rw  . ,(λ (f) (letm ((s get-pos) (f f) (_ (set-pos s))) (return f))))
      (out . ,(λ (f) (bind f (λ (s) (display s) (return s)))))
      (rcat . ,(λ (a b) (λ (s) (letm ((a (a s))
                                      (b (b s)))
                                 (return (string-append a b))))))))

  (define (subp f)
    (λ (s) (letm ((s0 get-pos)
                  (_ (set-pos s))
                  (f f)
                  (_ eof)
                  (_ (set-pos s0)))
             (return f))))

  (define (linguify b hs)
    (let* ((k (if (pair? b) (car b) b))
           (h (cdr (assq k hs))))
      (case k ((dot eof) h)
              ((atom lterm rterm call) (h (cdr b)))
              ((rep opt neg out rw) (h (linguify (cdr b) hs)))
              ((lcat rcat alt and map)
               (h (linguify (cadr b) hs) (linguify (cddr b) hs))))))

  (define (make-procedure defs entry-point)
    (define (dispatch a) (define-lazy f (cdr (assq a rules))) f)
    (define handlers
      (append static-handlers (list (cons 'atom dispatch)
                                    (cons 'call (compose subp dispatch)))))
    (define (defn t d) (cons (cons (cdadr d) (linguify (cddr d) handlers)) t))
    (define rules (fold-left defn '() defs))
    (cdr (assq entry-point rules))))
